"""
Clock Tree Visualization Module

This module provides functions to visualize clock trees generated by the DME algorithm
using SVG format for clear, scalable graphics.
"""

import doctest
from typing import List, Tuple, Dict, Any
from physdes.point import Point


class ClockTreeVisualizer:
    """Visualizes clock trees in SVG format"""

    def __init__(
        self,
        margin: int = 50,
        node_radius: int = 8,
        wire_width: int = 2,
        sink_color: str = "#4CAF50",
        internal_color: str = "#2196F3",
        root_color: str = "#F44336",
        wire_color: str = "#666666",
        text_color: str = "#333333",
    ):
        """
        Initialize the visualizer with styling parameters

        Args:
            margin: Margin around the drawing
            node_radius: Radius of node circles
            wire_width: Width of wire lines
            sink_color: Color for sink nodes
            internal_color: Color for internal nodes
            root_color: Color for root node
            wire_color: Color for wires
            text_color: Color for text labels

        Examples:
            >>> viz = ClockTreeVisualizer(margin=10, node_radius=5)
            >>> viz.margin
            10
            >>> viz.node_radius
            5
        """
        self.margin = margin
        self.node_radius = node_radius
        self.wire_width = wire_width
        self.sink_color = sink_color
        self.internal_color = internal_color
        self.root_color = root_color
        self.wire_color = wire_color
        self.text_color = text_color

    def visualize_tree(
        self,
        root,
        sinks: List,
        filename: str = "clock_tree.svg",
        width: int = 800,
        height: int = 600,
    ) -> str:
        """
        Create an SVG visualization of the clock tree

        Args:
            root: Root node of the clock tree
            sinks: List of original sink objects
            filename: Output filename
            width: SVG width
            height: SVG height

        Returns:
            SVG string content
        """
        # Collect all nodes and calculate bounds
        all_nodes = self._collect_all_nodes(root)
        min_x, min_y, max_x, max_y = self._calculate_bounds(all_nodes, sinks)

        # Scale coordinates to fit SVG canvas
        scale_x = (width - 2 * self.margin) / (max_x - min_x) if max_x > min_x else 1
        scale_y = (height - 2 * self.margin) / (max_y - min_y) if max_y > min_y else 1
        scale = min(scale_x, scale_y)  # Maintain aspect ratio

        def scale_coord(x, y):
            scaled_x = (x - min_x) * scale + self.margin
            scaled_y = (y - min_y) * scale + self.margin
            return scaled_x, scaled_y

        # Create SVG content
        svg_content = [
            f'<svg width="{width}" height="{height}" xmlns="http://www.w3.org/2000/svg">',
            "<style>",
            "  .node-label { font: 10px sans-serif; fill: #333; }",
            "  .delay-label { font: 8px sans-serif; fill: #666; }",
            "  .wire-label { font: 9px sans-serif; fill: #444; }",
            "</style>",
            '<rect width="100%" height="100%" fill="white"/>',
            '<g class="clock-tree">',
        ]

        # Draw wires first (so they appear behind nodes)
        svg_content.extend(self._draw_wires(root, scale_coord))

        # Draw nodes
        svg_content.extend(self._draw_nodes(root, sinks, scale_coord))

        # Close SVG
        svg_content.extend(["</g>", "</svg>"])

        svg_string = "\n".join(svg_content)

        # Save to file
        with open(filename, "w") as f:
            f.write(svg_string)

        print(f"Clock tree visualization saved to {filename}")
        return svg_string

    def _collect_all_nodes(self, root) -> List:
        """Collect all nodes in the tree"""
        nodes = []

        def collect(node):
            if node:
                nodes.append(node)
                collect(node.left)
                collect(node.right)

        collect(root)
        return nodes

    def _calculate_bounds(
        self, nodes: List, sinks: List
    ) -> Tuple[float, float, float, float]:
        """Calculate the bounding box of all nodes and sinks"""
        all_points = []

        # Add tree nodes
        for node in nodes:
            all_points.append((node.position.xcoord, node.position.ycoord))

        # Add original sinks (in case some are not in the tree)
        for sink in sinks:
            all_points.append((sink.position.xcoord, sink.position.ycoord))

        if not all_points:
            return 0, 0, 100, 100

        min_x = min(x for x, y in all_points)
        max_x = max(x for x, y in all_points)
        min_y = min(y for x, y in all_points)
        max_y = max(y for x, y in all_points)

        # Add some padding
        padding = max((max_x - min_x) * 0.1, (max_y - min_y) * 0.1, 10)

        return (min_x - padding, min_y - padding, max_x + padding, max_y + padding)

    def _draw_wires(self, root, scale_coord) -> List[str]:
        """Draw all wires in the clock tree"""
        svg_elements = []

        def draw_wires_recursive(node):
            if not node:
                return

            if node.parent:
                # Draw wire from parent to current node
                x1, y1 = scale_coord(
                    node.parent.position.xcoord, node.parent.position.ycoord
                )
                x2, y2 = scale_coord(node.position.xcoord, node.position.ycoord)

                svg_elements.append(
                    f'<line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}" '
                    f'stroke="{self.wire_color}" stroke-width="{self.wire_width}" '
                    f'stroke-linecap="round"/>'
                )

                # Add wire length label
                mid_x = (x1 + x2) / 2
                mid_y = (y1 + y2) / 2
                if hasattr(node, "wire_length") and node.wire_length > 0:
                    svg_elements.append(
                        f'<text x="{mid_x}" y="{mid_y - 5}" class="wire-label" '
                        f'text-anchor="middle">{node.wire_length:.1f}</text>'
                    )

            draw_wires_recursive(node.left)
            draw_wires_recursive(node.right)

        draw_wires_recursive(root)
        return svg_elements

    def _draw_nodes(self, root, sinks, scale_coord) -> List[str]:
        """Draw all nodes in the clock tree"""
        svg_elements = []
        sink_positions = {
            (sink.position.xcoord, sink.position.ycoord) for sink in sinks
        }

        def draw_nodes_recursive(node, depth=0):
            if not node:
                return

            x, y = scale_coord(node.position.xcoord, node.position.ycoord)

            # Determine node type and color
            is_sink = (node.position.xcoord, node.position.ycoord) in sink_positions
            is_root = node.parent is None

            if is_root:
                color = self.root_color
                radius = self.node_radius + 2
            elif is_sink:
                color = self.sink_color
                radius = self.node_radius
            else:
                color = self.internal_color
                radius = self.node_radius - 2

            # Draw node circle
            svg_elements.append(
                f'<circle cx="{x}" cy="{y}" r="{radius}" fill="{color}" '
                f'stroke="#333" stroke-width="1"/>'
            )

            # Draw node label
            label_y_offset = -radius - 5
            svg_elements.append(
                f'<text x="{x}" y="{y + label_y_offset}" class="node-label" '
                f'text-anchor="middle">{node.name}</text>'
            )

            # Draw delay information if available
            if hasattr(node, "delay"):
                delay_y_offset = radius + 12
                svg_elements.append(
                    f'<text x="{x}" y="{y + delay_y_offset}" class="delay-label" '
                    f'text-anchor="middle">d:{node.delay:.1f}</text>'
                )

            # Draw capacitance information for sinks
            if is_sink and hasattr(node, "capacitance"):
                cap_y_offset = radius + 22
                svg_elements.append(
                    f'<text x="{x}" y="{y + cap_y_offset}" class="delay-label" '
                    f'text-anchor="middle">c:{node.capacitance:.1f}</text>'
                )

            draw_nodes_recursive(node.left, depth + 1)
            draw_nodes_recursive(node.right, depth + 1)

        draw_nodes_recursive(root)
        return svg_elements


def create_interactive_svg(
    root,
    sinks: List,
    analysis: Dict[str, Any],
    filename: str = "clock_tree_interactive.svg",
) -> str:
    """
    Create an interactive SVG with additional information and styling

    Args:
        root: Root node of clock tree
        sinks: List of sink objects
        analysis: Skew analysis results
        filename: Output filename

    Returns:
        SVG string content
    """

    visualizer = ClockTreeVisualizer(
        margin=60,
        node_radius=10,
        wire_width=3,
        sink_color="#2E7D32",
        internal_color="#1565C0",
        root_color="#C62828",
        wire_color="#455A64",
        text_color="#263238",
    )

    svg_content = visualizer.visualize_tree(root, sinks, filename, 1000, 700)

    # Enhance with analysis information
    enhanced_svg = _add_analysis_info(svg_content, analysis)

    with open(filename, "w") as f:
        f.write(enhanced_svg)

    return enhanced_svg


def _add_analysis_info(svg_content: str, analysis: Dict[str, Any]) -> str:
    """Add analysis information to the SVG

    Examples:
        >>> svg = '<svg><g class="clock-tree"></g></svg>'
        >>> analysis = {"skew": 0.03}
        >>> enhanced_svg = _add_analysis_info(svg, analysis)
        >>> "Skew: 0.030" in enhanced_svg
        True
    """

    analysis_text = [
        "Clock Tree Analysis",
        f"Max Delay: {analysis.get('max_delay', 0):.3f}",
        f"Min Delay: {analysis.get('min_delay', 0):.3f}",
        f"Skew: {analysis.get('skew', 0):.3f}",
        f"Total Wirelength: {analysis.get('total_wirelength', 0):.1f}",
        f"Sinks: {len(analysis.get('sink_delays', []))}",
    ]

    # Insert analysis box at the beginning of the SVG
    lines = svg_content.split("\n")

    # Find the position after the opening SVG tag and style
    insert_pos = 0
    for i, line in enumerate(lines):
        if '<g class="clock-tree">' in line:
            insert_pos = i
            break

    # Create analysis box
    analysis_box = [
        '<g class="analysis-info">',
        '<rect x="10" y="10" width="200" height="120" fill="white" stroke="#ccc" stroke-width="1" rx="5"/>',
        '<text x="20" y="30" font-family="monospace" font-size="12" fill="#333">',
    ]

    for i, text in enumerate(analysis_text):
        analysis_box.append(f'<tspan x="20" y="{30 + (i + 1) * 18}">{text}</tspan>')

    analysis_box.append("</text>")
    analysis_box.append("</g>")

    # Insert analysis box
    lines[insert_pos:insert_pos] = analysis_box

    return "\n".join(lines)


def create_animated_tree_construction(
    root, sinks: List, filename: str = "clock_tree_animated.svg"
) -> str:
    """
    Create an animated SVG showing the tree construction process

    Args:
        root: Root node of clock tree
        sinks: List of sink objects
        filename: Output filename

    Returns:
        SVG string content
    """
    # This would require more complex SVG animation features
    # For now, return a static visualization
    print("Animated version not yet implemented. Creating static visualization.")
    return create_interactive_svg(root, sinks, {}, filename)


# Example usage function
def visualize_example_tree():
    """Example function demonstrating clock tree visualization"""
    from physdes.dme_algorithm import Sink, example_dme_usage

    # Generate example clock tree
    clock_tree, analysis = example_dme_usage()

    # Get sinks from the example (in practice, you'd have your actual sinks)
    example_sinks = [
        Sink("s1", Point(10, 20), 1.0),
        Sink("s2", Point(30, 40), 1.0),
        Sink("s3", Point(50, 10), 1.0),
        Sink("s4", Point(70, 30), 1.0),
        Sink("s5", Point(90, 50), 1.0),
    ]

    # Create visualizations
    visualizer = ClockTreeVisualizer()

    # Basic visualization
    basic_svg = visualizer.visualize_tree(
        clock_tree, example_sinks, "basic_clock_tree.svg"
    )

    # Interactive visualization with analysis
    interactive_svg = create_interactive_svg(
        clock_tree, example_sinks, analysis, "interactive_clock_tree.svg"
    )

    print("Visualizations created:")
    print("- basic_clock_tree.svg: Basic tree structure")
    print("- interactive_clock_tree.svg: With analysis information")

    return basic_svg, interactive_svg


if __name__ == "__main__":
    # Run example visualization
    basic, interactive = visualize_example_tree()
    doctest.testmod()
