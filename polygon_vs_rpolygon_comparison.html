<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon vs Rectilinear Polygon (RPolygon): A Comprehensive Comparison üîç</title>
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    
    <!-- Mermaid JS -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --background-color: #f8f9fa;
            --text-color: #2c3e50;
            --code-bg: #2d2d2d;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 300;
        }

        h2 {
            color: var(--primary-color);
            border-bottom: 3px solid var(--secondary-color);
            padding-bottom: 0.5rem;
            margin-top: 2.5rem;
            margin-bottom: 1.5rem;
        }

        h3 {
            color: var(--secondary-color);
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        h4 {
            color: var(--accent-color);
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 0.5rem;
        }

        .math-block {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            border-left: 4px solid var(--secondary-color);
            overflow-x: auto;
        }

        .highlight-box {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .highlight-box h4 {
            color: #856404;
            margin-top: 0;
        }

        .mermaid-container {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        pre {
            background: var(--code-bg);
            color: #f8f8f2;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .inline-code {
            background: #e9ecef;
            color: var(--primary-color);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .image-container {
            text-align: center;
            margin: 2rem 0;
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .benefits-list {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .benefits-list ul {
            margin: 0;
            padding-left: 1.5rem;
        }

        .benefits-list li {
            margin-bottom: 0.5rem;
        }

        .storage-comparison {
            background: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .storage-comparison code {
            background: #e9ecef;
            color: var(--primary-color);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }

        .conclusion {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            border-radius: 10px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .references {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .references ol {
            padding-left: 1.5rem;
        }

        .references li {
            margin-bottom: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Polygon vs Rectilinear Polygon (RPolygon): A Comprehensive Comparison üîç</h1>
        </header>

        <main>
            <h2><span class="emoji">üìñ</span>Introduction</h2>
            <p>In computational geometry and VLSI physical design, polygons represent fundamental geometric primitives. This essay provides an in-depth comparison between the <code>Polygon</code> and <code>RPolygon</code> (Rectilinear Polygon) classes from the physdes-py library, examining their implementation details, mathematical foundations, practical applications, and performance characteristics. Through source code analysis, algorithmic comparisons, and visual examples, we'll explore both the shared foundations and key distinctions that make these polygon types suited for different computational tasks.</p>

            <h2><span class="emoji">üßÆ</span>Mathematical Foundations</h2>
            
            <h3><span class="emoji">üìê</span>General Polygons: The Arbitrary Angle Domain</h3>
            <p>A general polygon is defined as a closed planar shape formed by a finite sequence of line segments. Mathematically, we can represent a polygon $P$ as an ordered sequence of vertices $v_0, v_1, \ldots, v_{n-1}$ where each vertex $v_i = (x_i, y_i)$ in $\mathbb{R}^2$ and edges connect consecutive vertices $(v_i, v_{i+1})$ with $v_n = v_0$.</p>
            
            <div class="math-block">
                <p>The signed area of a polygon using the Shoelace formula is:</p>
                $$A = \frac{1}{2} \sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)$$
                <p>where indices are computed modulo $n$.</p>
            </div>

            <h3><span class="emoji">üìè</span>Rectilinear Polygons: The Orthogonal Constraint</h3>
            <p>A rectilinear polygon is a special case where all edges are either horizontal or vertical. This constraint means that for any edge $(v_i, v_{i+1})$, either $x_i = x_{i+1}$ (vertical edge) or $y_i = y_{i+1}$ (horizontal edge).</p>
            
            <p>This orthogonal constraint provides significant computational advantages:</p>
            <div class="benefits-list">
                <ul>
                    <li><strong>Simplified intersection testing</strong>: Edge-edge intersection reduces to simple coordinate comparisons</li>
                    <li><strong>Efficient area calculation</strong>: Area can be computed using a simpler summation formula</li>
                    <li><strong>Specialized algorithms</strong>: Many polygon operations have optimized implementations for rectilinear cases</li>
                </ul>
            </div>

            <div class="highlight-box">
                <h4><span class="emoji">üî•</span>Critical Optimization: Even-Index Vertex Storage</h4>
                <p>One of the most innovative aspects of the <code>RPolygon</code> implementation is its clever vertex storage strategy. <strong>The RPolygon class only stores vertices at even indices: $\{v_0, v_2, v_4, \ldots\}$</strong>. This optimization leverages a fundamental property of rectilinear polygons:</p>
                
                <p>In a rectilinear polygon, consecutive vertices alternate between horizontal and vertical edges. This means that given any two consecutive stored vertices $v_{2i}$ and $v_{2i+2}$, the intermediate vertex $v_{2i+1}$ can be <strong>uniquely determined</strong> as either:</p>
                <ul>
                    <li>$(x_{2i}, y_{2i+2})$ if the edge from $v_{2i}$ to $v_{2i+1}$ is vertical</li>
                    <li>$(x_{2i+2}, y_{2i})$ if the edge from $v_{2i}$ to $v_{2i+1}$ is horizontal</li>
                </ul>

                <p><strong>Benefits of this optimization:</strong></p>
                <div class="benefits-list">
                    <ul>
                        <li><strong>50% Memory Reduction</strong>: Storage requirements are literally cut in half</li>
                        <li><strong>Algorithm Simplification</strong>: Many algorithms can work directly with the reduced vertex set</li>
                        <li><strong>Improved Cache Performance</strong>: Smaller data structures lead to better cache utilization</li>
                        <li><strong>Simplified Indexing</strong>: Eliminates the need to handle redundant vertices in loops</li>
                    </ul>
                </div>

                <div class="math-block">
                    <p><strong>Mathematical Foundation:</strong></p>
                    <p>For a rectilinear polygon with $n$ vertices, the traditional storage requires $n$ points. The optimized storage requires only $\lceil n/2 \rceil$ points, with the relationship:</p>
                    $$v_{2i+1} = \begin{cases}
                    (x_{2i}, y_{2i+2}) & \text{if } x_{2i} = x_{2i+1} \\
                    (x_{2i+2}, y_{2i}) & \text{if } y_{2i} = y_{2i+1}
                    \end{cases}$$
                </div>

                <p>This optimization is particularly powerful in VLSI applications where millions of rectilinear polygons may be processed simultaneously.</p>
            </div>

            <h2><span class="emoji">üèóÔ∏è</span>Implementation Architecture</h2>
            
            <h3>Class Hierarchies and Design Patterns</h3>
            <div class="mermaid-container">
                <div class="mermaid">
                    classDiagram
                        class Polygon {
                            -_origin: Point[T, T]
                            -_vecs: List[Vector2[T, T]]
                            +from_pointset(pointset: PointSet): Polygon[T]
                            +signed_area_x2: Any
                            +is_rectilinear(): bool
                            +is_anticlockwise(): bool
                            +is_convex(): bool
                        }
                        
                        class RPolygon {
                            -_origin: Point[int, int]
                            -_vecs: List[Vector2[int, int]]
                            +from_pointset(pointset: PointSet): RPolygon
                            +signed_area: int
                            +is_anticlockwise(): bool
                            +to_polygon(): Polygon[int]
                        }
                        
                        class Point {
                            +xcoord: T1
                            +ycoord: T2
                            +displace(other: Point): Vector2
                        }
                        
                        class Vector2 {
                            +x: T1
                            +y: T2
                            +cross(other: Vector2): T
                        }
                        
                        Polygon --> Point
                        Polygon --> Vector2
                        RPolygon --> Point
                        RPolygon --> Vector2
                        RPolygon ..> Polygon : converts to
                </div>
            </div>

            <h3>Key Architectural Differences</h3>
            
            <h4><span class="emoji">üéØ</span>1. Type System and Generics</h4>
            <p>The <code>Polygon</code> class uses generic typing with <code>T = TypeVar("T", int, float)</code>, allowing for both integer and floating-point coordinates:</p>
            <pre><code class="language-python">class Polygon(Generic[T]):
    _origin: Point[T, T]
    _vecs: List[Vector2[Any, Any]]</code></pre>

            <p>In contrast, <code>RPolygon</code> is specifically constrained to integer coordinates:</p>
            <pre><code class="language-python">class RPolygon:
    _origin: Point[int, int]
    _vecs: List[Vector2[int, int]]</code></pre>

            <p>This design choice reflects the typical use cases in VLSI design where rectilinear polygons often represent circuit layouts on discrete grids.</p>

            <h4><span class="emoji">üìä</span>2. Internal Representation</h4>
            <p>While both classes share a similar constructor pattern using an origin point and a list of displacement vectors, their internal representations differ fundamentally:</p>
            <pre><code class="language-python"># Common pattern in both classes
def __init__(self, origin: Point[T, T], vecs: List[Vector2[T, T]]) -> None:
    self._origin = origin
    self._vecs = vecs</code></pre>

            <p>However, the interpretation and storage strategy differ significantly:</p>
            <ul>
                <li><strong>Polygon</strong>: Vectors represent arbitrary directional edges, storing all vertices $\{v_0, v_1, v_2, \ldots, v_{n-1}\}$</li>
                <li><strong>RPolygon</strong>: Implements the <strong>even-index optimization</strong>, storing only $\{v_0, v_2, v_4, \ldots\}$ with implicit reconstruction of odd-index vertices</li>
            </ul>

            <div class="storage-comparison">
                <p><strong>Storage Comparison:</strong></p>
                <pre><code class="language-python"># Polygon: Stores all vertices
polygon_vertices = [v0, v1, v2, v3, v4, v5, v6, v7]  # 8 vertices

# RPolygon: Stores only even indices
rpolygon_vertices = [v0, v2, v4, v6]  # 4 vertices, v1, v3, v5, v7 are implicit</code></pre>
            </div>

            <p>This fundamental difference impacts all algorithms that operate on these structures, with RPolygon algorithms designed to work with the compressed representation while Polygon algorithms handle the complete vertex set.</p>

            <h2><span class="emoji">‚öôÔ∏è</span>Algorithmic Comparisons</h2>
            
            <h3>Area Calculation Algorithms</h3>
            
            <h4>Polygon: Shoelace Formula Implementation</h4>
            <pre><code class="language-python">@cached_property
def signed_area_x2(self) -> Any:
    assert len(self._vecs) >= 2
    itr = iter(self._vecs)
    vec0 = next(itr)
    vec1 = next(itr)
    res = vec0.x * vec1.y - self._vecs[-1].x * self._vecs[-2].y
    for vec2 in itr:
        res += vec1.x * (vec2.y - vec0.y)
        vec0 = vec1
        vec1 = vec2
    return res</code></pre>

            <p>This implementation uses an optimized version of the Shoelace formula with $O(n)$ time complexity.</p>

            <h4>RPolygon: Optimized Area Calculation with Even-Index Storage</h4>
            <pre><code class="language-python">@cached_property
def signed_area(self) -> int:
    if len(self._vecs) < 1:
        return 0
    vec0 = self._vecs[0]
    return sum(
        [v1.x * (v1.y - v0.y) for v0, v1 in zip(self._vecs[:-1], self._vecs[1:])],
        vec0.x * vec0.y,
    )</code></pre>

            <p>This implementation is particularly elegant because it leverages <strong>both</strong> the rectilinear constraint <strong>and</strong> the even-index storage optimization. The algorithm works directly on the compressed vertex set $\{v_0, v_2, v_4, \ldots\}$ without needing to reconstruct the intermediate vertices.</p>

            <div class="math-block">
                <p><strong>Mathematical Insight:</strong></p>
                <p>For a rectilinear polygon with vertices $\{v_0, v_1, v_2, \ldots, v_{n-1}\}$, the area can be computed using only the even-index vertices:</p>
                $$A = \sum_{i=0}^{k-1} x_{2i} \cdot (y_{2i+2} - y_{2i})$$
                <p>where $k = \lceil n/2 \rceil$ and indices are computed modulo $k$. This formula emerges because:</p>
                <ol>
                    <li>Horizontal edges contribute zero to the cross product</li>
                    <li>The intermediate vertices cancel out in the alternating sum</li>
                    <li>Only the "corner" vertices (even indices) contribute to the area</li>
                </ol>
            </div>

            <p>This optimization reduces both computational complexity and memory access patterns, making the area calculation approximately twice as efficient as the general polygon case.</p>

            <h3>Point-in-Polygon Testing</h3>
            
            <h4>Polygon: Ray Casting Algorithm</h4>
            <pre><code class="language-python">def point_in_polygon(pointset: PointSet, ptq: Point[T, T]) -> bool:
    res = False
    pt0 = pointset[-1]
    for pt1 in pointset:
        if (pt1.ycoord <= ptq.ycoord < pt0.ycoord) or (
            pt0.ycoord <= ptq.ycoord < pt1.ycoord
        ):
            det = ptq.displace(pt0).cross(pt1.displace(pt0))
            if pt1.ycoord > pt0.ycoord:
                if det < 0:
                    res = not res
            else:  # v1.ycoord < v0.ycoord
                if det > 0:
                    res = not res
        pt0 = pt1
    return res</code></pre>

            <p>This implementation uses the classic ray-casting algorithm with $O(n)$ complexity.</p>

            <h4>RPolygon: Optimized Ray Casting</h4>
            <pre><code class="language-python">def point_in_rpolygon(pointset: PointSet, ptq: Point[int, int]) -> bool:
    res = False
    pt0 = pointset[-1]
    for pt1 in pointset:
        if (
            (pt1.ycoord <= ptq.ycoord < pt0.ycoord)
            or (pt0.ycoord <= ptq.ycoord < pt1.ycoord)
            and pt1.xcoord > ptq.xcoord
        ):
            res = not res
        pt0 = pt1
    return res</code></pre>

            <p>The rectilinear version eliminates the cross product calculation since the intersection test reduces to simple coordinate comparisons.</p>

            <h2><span class="emoji">üìà</span>Monotonicity Properties</h2>
            
            <h3>X-Monotone and Y-Monotone Polygons</h3>
            <p>A polygon is x-monotone if every vertical line intersects the polygon in at most one connected segment. Similarly, a polygon is y-monotone if every horizontal line has this property.</p>

            <h4>Polygon Monotonicity Testing</h4>
            <pre><code class="language-python">def polygon_is_monotone(lst: PointSet, dir: Callable[[Point[T, T]], Any]) -> bool:
    if len(lst) <= 3:
        return True

    min_index, _ = min(enumerate(lst), key=lambda it: dir(it[1]))
    max_index, _ = max(enumerate(lst), key=lambda it: dir(it[1]))
    rdll = RDllist(len(lst))

    def voilate(start: int, stop: int, cmp: Callable[[Any, Any], bool]) -> bool:
        vi = rdll[start]
        while id(vi) != id(rdll[stop]):
            vnext = vi.next
            if cmp(dir(lst[vi.data])[0], dir(lst[vnext.data])[0]):
                return True
            vi = vnext
        return False

    # Chain from min to max
    if voilate(min_index, max_index, lambda a, b: a > b):
        return False

    # Chain from max to min
    return not voilate(max_index, min_index, lambda a, b: a < b)</code></pre>

            <h4>RPolygon Monotonicity Testing</h4>
            <p>The RPolygon version uses a similar approach but with optimizations specific to rectilinear structures:</p>
            <pre><code class="language-python">def rpolygon_is_monotone(
    lst: PointSet, dir: Callable[[Point[int, int]], Tuple[int, int]]
) -> bool:
    if len(lst) <= 3:
        return True

    min_index, _ = min(enumerate(lst), key=lambda it: dir(it[1]))
    max_index, _ = max(enumerate(lst), key=lambda it: dir(it[1]))
    rdll = RDllist(len(lst))
    v_min = rdll[min_index]
    v_max = rdll[max_index]

    def voilate(
        vi: Dllink[int], v_stop: Dllink[int], cmp: Callable[[int, int], bool]
    ) -> bool:
        while id(vi) != id(v_stop):
            vnext = vi.next
            if cmp(dir(lst[vi.data])[0], dir(lst[vnext.data])[0]):
                return True
            vi = vnext
        return False

    # Chain from min to max
    if voilate(v_min, v_max, lambda val1, val2: val1 > val2):
        return False

    # Chain from max to min
    return not voilate(v_max, v_min, lambda val1, val2: val1 < val2)</code></pre>

            <h2><span class="emoji">üîç</span>Convexity Analysis</h2>
            
            <h4>Polygon Convexity Testing</h4>
            <pre><code class="language-python">def is_convex(self, is_anticlockwise: bool | None = None) -> bool:
    if len(self._vecs) < 3:
        return True  # A polygon with less than 3 points is considered convex

    if is_anticlockwise is None:
        is_anticlockwise = self.is_anticlockwise()

    pointset: List[Vector2[T, T]] = [Vector2(0, 0)] + self._vecs
    # Check the cross product of all consecutive edges
    if is_anticlockwise:
        return all(
            (pointset[i] - pointset[i - 1]).cross(pointset[i + 1] - pointset[i])
            >= 0
            for i in range(len(pointset) - 1)
        )
    else:
        return all(
            (pointset[i] - pointset[i - 1]).cross(pointset[i + 1] - pointset[i])
            <= 0
            for i in range(len(pointset) - 1)
        )</code></pre>

            <h4>RPolygon Convexity Testing</h4>
            <p>For rectilinear polygons, convexity can be determined by checking both x-monotonicity and y-monotonicity:</p>
            <pre><code class="language-python">def rpolygon_is_convex(lst: PointSet) -> bool:
    return rpolygon_is_xmonotone(lst) and rpolygon_is_ymonotone(lst)</code></pre>

            <p>This elegant property holds because a rectilinear polygon is convex if and only if it is monotone in both coordinate directions.</p>

            <h2><span class="emoji">üîÑ</span>Conversion Between Types</h2>
            
            <h3>RPolygon to Polygon Conversion: Vertex Expansion</h3>
            <p>The <code>RPolygon</code> class provides a method to convert to a general polygon by <strong>expanding the compressed even-index representation</strong> back to the full vertex sequence:</p>
            <pre><code class="language-python">def to_polygon(self) -> Polygon[int]:
    new_vecs: List[Vector2[int, int]] = []
    current_pt: Vector2[int, int] = Vector2(0, 0)

    for next_pt in self._vecs:
        if current_pt.x != next_pt.x and current_pt.y != next_pt.y:
            # Reconstruct the implicit intermediate vertex
            new_vecs.append(Vector2(next_pt.x, current_pt.y))
        new_vecs.append(next_pt)
        current_pt = next_pt

    # Closing segment - reconstruct final implicit vertex if needed
    first_pt: Vector2[int, int] = Vector2(0, 0)
    if current_pt.x != first_pt.x and current_pt.y != first_pt.y:
        new_vecs.append(Vector2(first_pt.x, current_pt.y))

    return Polygon(self._origin, new_vecs)</code></pre>

            <div class="highlight-box">
                <h4>Vertex Expansion Process:</h4>
                <ol>
                    <li><strong>Input</strong>: Compressed vertices $\{v_0, v_2, v_4, \ldots, v_{2k}\}$</li>
                    <li><strong>Reconstruction</strong>: For each pair $(v_{2i}, v_{2i+2})$, insert $v_{2i+1}$:
                        <ul>
                            <li>If $x_{2i} = x_{2i+2}$ (vertical edge), then $v_{2i+1} = (x_{2i}, y_{2i+2})$</li>
                            <li>If $y_{2i} = y_{2i+2}$ (horizontal edge), then $v_{2i+1} = (x_{2i+2}, y_{2i})$</li>
                        </ul>
                    </li>
                    <li><strong>Output</strong>: Full vertex sequence $\{v_0, v_1, v_2, \ldots, v_{n-1}\}$</li>
                </ol>

                <p><strong>Performance Considerations:</strong></p>
                <p>This expansion process has $O(n)$ complexity and temporarily doubles the memory usage during conversion. However, it's only performed when necessary, allowing the RPolygon to maintain its storage efficiency during most operations.</p>

                <p><strong>Use Cases:</strong></p>
                <ul>
                    <li><strong>Algorithm Compatibility</strong>: When using general polygon algorithms that require full vertex sequences</li>
                    <li><strong>Visualization</strong>: For rendering systems that expect complete polygon definitions</li>
                    <li><strong>File Formats</strong>: When exporting to formats that don't support compressed representations</li>
                    <li><strong>Interoperability</strong>: When interfacing with libraries that only handle general polygons</li>
                </ul>
            </div>

            <h2><span class="emoji">‚úÇÔ∏è</span>Convex Decomposition Algorithms</h2>
            
            <h3>RPolygon Convex Cutting: Recursive Partitioning Strategy</h3>
            <p>One of the most powerful operations available for rectilinear polygons is convex decomposition - the process of breaking down a concave polygon into a set of convex components. The <code>rpolygon_cut_convex()</code> function implements an elegant recursive algorithm that leverages the orthogonal constraints to achieve efficient decomposition.</p>

            <h4>Algorithm Overview</h4>
            <p>The convex decomposition process follows these key steps:</p>
            <ol>
                <li><strong>Concave Vertex Detection</strong>: Identify vertices where the internal angle exceeds 180¬∞</li>
                <li><strong>Optimal Cut Selection</strong>: Find the nearest vertex to connect with, minimizing cut length</li>
                <li><strong>Polygon Splitting</strong>: Create a new vertex at the intersection point and split the polygon</li>
                <li><strong>Recursive Processing</strong>: Apply the same process to resulting sub-polygons</li>
            </ol>

            <h4>Mathematical Foundation</h4>
            <p>For a rectilinear polygon, concavity can be detected using the cross product of consecutive edges:</p>
            <div class="math-block">
                $$\text{concave}(v_i) = \begin{cases}
                \text{True} & \text{if } (v_{i-1} - v_i) \times (v_{i+1} - v_i) < 0 \text{ (anticlockwise)} \\
                \text{True} & \text{if } (v_{i-1} - v_i) \times (v_{i+1} - v_i) > 0 \text{ (clockwise)} \\
                \text{False} & \text{otherwise}
                \end{cases}$$
            </div>

            <h4>Implementation Details</h4>
            <pre><code class="language-python">def rpolygon_cut_convex(lst: PointSet, is_anticlockwise: bool) -> List[PointSet]:
    """
    Cuts a rectilinear polygon into a set of convex rectilinear polygons.
    
    This function implements a recursive algorithm to partition a given rectilinear
    polygon into a set of convex components. The process begins by identifying a
    concave vertex in the polygon. Once a concave vertex is found, a cut is made to
    another vertex in the polygon, effectively splitting the polygon into two smaller
    polygons. This process is then applied recursively to the resulting polygons until
    all of them are convex.
    """
    rdll = RDllist(len(lst))
    vertices_list = rpolygon_cut_convex_recur(rdll[0], lst, is_anticlockwise, rdll)
    res = list()
    for item in vertices_list:
        points = [lst[i] for i in item]
        res.append(points)
    return res</code></pre>

            <h4>Distance-Based Cut Selection</h4>
            <p>The algorithm uses a sophisticated distance-based approach to select optimal cuts:</p>
            <pre><code class="language-python">def find_min_dist_point(lst: PointSet, vcurr: Dllink[int]) -> Tuple[Dllink[int], bool]:
    """
    Finds the point in a polygon that is closest to a given vertex.
    
    This function is a key helper for the polygon cutting algorithms. When a concave
    vertex is identified, this function is used to find the best vertex to connect it
    to, in order to create a cut that resolves the concavity. The "best" vertex is
    the one that is closest in either the horizontal or vertical direction.
    """
    vnext = vcurr.next
    vprev = vcurr.prev
    vi = vnext.next
    min_value = math.inf
    vertical = True
    v_min = vcurr
    pcurr = lst[vcurr.data]
    while id(vi) != id(vprev):
        prev_point = lst[vi.prev.data]
        curr_point = lst[vi.data]
        next_point = lst[vi.next.data]
        vec_i = curr_point.displace(pcurr)
        if (prev_point.ycoord <= pcurr.ycoord <= curr_point.ycoord) or (
            curr_point.ycoord <= pcurr.ycoord <= prev_point.ycoord
        ):
            if abs(vec_i.x_) < min_value:
                min_value = abs(vec_i.x_)
                v_min = vi
                vertical = True
        if (next_point.xcoord <= pcurr.xcoord <= curr_point.xcoord) or (
            curr_point.xcoord <= pcurr.xcoord <= next_point.xcoord
        ):
            if abs(vec_i.y_) < min_value:
                min_value = abs(vec_i.y_)
                v_min = vi
                vertical = False
        vi = vi.next
    return v_min, vertical</code></pre>

            <h4>Visual Examples</h4>
            <p>The following visualizations demonstrate the convex decomposition process:</p>

            <div class="highlight-box">
                <h4>Example 1: Complex Rectilinear Polygon Decomposition</h4>
                <div class="image-container">
                    <img src="outputs/rpolyon_cut_convex.svg" alt="RPolygon Convex Decomposition Example 1" style="max-width: 600px;">
                </div>
                <p>This example shows a complex rectilinear polygon (blue outline) being decomposed into 8 convex components (colored regions). Each colored region represents a convex rectilinear polygon that can be processed independently.</p>
            </div>

            <div class="highlight-box">
                <h4>Example 2: Alternative Decomposition Strategy</h4>
                <div class="image-container">
                    <img src="outputs/rpolyon_cut_convex2.svg" alt="RPolygon Convex Decomposition Example 2" style="max-width: 600px;">
                </div>
                <p>This second example demonstrates how different concave vertices and cut strategies can result in alternative decompositions, showing the flexibility of the algorithm.</p>
            </div>

            <h4>Algorithm Complexity Analysis</h4>
            <div class="highlight-box">
                <p><strong>Time Complexity</strong>: $O(n^2)$ in the worst case, where $n$ is the number of vertices</p>
                <ul>
                    <li>Each recursive call processes $O(n)$ vertices to find concave points</li>
                    <li>In the worst case, we may have $O(n)$ recursive levels</li>
                    <li>However, practical performance is typically much better due to efficient cut selection</li>
                </ul>
                
                <p><strong>Space Complexity</strong>: $O(n)$ for the recursive call stack and data structures</p>
            </div>

            <h4>Advantages of RPolygon Convex Decomposition</h4>
            <div class="benefits-list">
                <ul>
                    <li><strong>Orthogonal Optimization</strong>: Leverages the rectilinear constraint for efficient cut selection</li>
                    <li><strong>Quality Guarantees</strong>: Produces well-shaped convex components with minimal cut lengths</li>
                    <li><strong>Recursive Simplicity</strong>: Clean divide-and-conquer approach that's easy to understand and implement</li>
                    <li><strong>Memory Efficiency</strong>: Works directly with the compressed even-index representation</li>
                </ul>
            </div>

            <h4>Applications in VLSI Design</h4>
            <p>Convex decomposition is particularly valuable in VLSI physical design:</p>
            <div class="benefits-list">
                <ul>
                    <li><strong>Design Rule Checking</strong>: Convex regions are easier to validate against manufacturing constraints</li>
                    <li><strong>Routing Optimization</strong>: Convex obstacles simplify path planning algorithms</li>
                    <li><strong>Partitioning</strong>: Enables hierarchical design approaches by breaking complex shapes into manageable pieces</li>
                    <li><strong>Mask Generation</strong>: Convex polygons are more efficient for photomask generation and verification</li>
                </ul>
            </div>

            <h4>Alternative: Explicit Cutting Algorithm</h4>
            <p>The library also provides <code>rpolygon_cut_explicit()</code>, an alternative implementation that uses a different strategy for concave vertex detection and cut selection:</p>
            <pre><code class="language-python">def rpolygon_cut_explicit(lst: PointSet, is_anticlockwise: bool) -> List[PointSet]:
    """
    Cuts a rectilinear polygon into a set of convex rectilinear polygons.
    
    This function provides an alternative algorithm for partitioning a rectilinear polygon
    into convex components. Like `rpolygon_cut_convex`, it works by identifying concave
    vertices and introducing cuts to resolve them. The underlying logic for selecting
    cuts and performing the partitioning may differ, but the end result is the same: a
    set of convex rectilinear polygons.
    """</code></pre>

            <p>This alternative can be useful when dealing with specific polygon geometries where one approach may produce better results than the other.</p>

            <h2><span class="emoji">‚ö°</span>Performance Characteristics</h2>
            
            <h3>Time Complexity Analysis</h3>
            <table>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Polygon</th>
                        <th>RPolygon</th>
                        <th>Advantage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Area Calculation</td>
                        <td>$O(n)$</td>
                        <td>$O(n)$</td>
                        <td>RPolygon has smaller constant factors</td>
                    </tr>
                    <tr>
                        <td>Point-in-Polygon</td>
                        <td>$O(n)$</td>
                        <td>$O(n)$</td>
                        <td>RPolygon eliminates cross products</td>
                    </tr>
                    <tr>
                        <td>Convexity Testing</td>
                        <td>$O(n)$</td>
                        <td>$O(n)$</td>
                        <td>RPolygon uses monotonicity property</td>
                    </tr>
                    <tr>
                        <td>Monotonicity Testing</td>
                        <td>$O(n)$</td>
                        <td>$O(n)$</td>
                        <td>Similar complexity</td>
                    </tr>
                    <tr>
                        <td>Edge Intersection</td>
                        <td>$O(n^2)$</td>
                        <td>$O(n)$</td>
                        <td>RPolygon uses simple comparisons</td>
                    </tr>
                </tbody>
            </table>

            <h3>Memory Usage</h3>
            <p>The memory usage patterns differ significantly due to the even-index storage optimization:</p>
            <table>
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Polygon</th>
                        <th>RPolygon</th>
                        <th>Reduction</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Origin Point</td>
                        <td>1 √ó Point</td>
                        <td>1 √ó Point</td>
                        <td>None</td>
                    </tr>
                    <tr>
                        <td>Vertex Storage</td>
                        <td>$n$ √ó Vector2</td>
                        <td>$\lceil n/2 \rceil$ √ó Vector2</td>
                        <td><strong>~50%</strong></td>
                    </tr>
                    <tr>
                        <td>Total Memory</td>
                        <td>$O(n)$</td>
                        <td>$O(n/2)$</td>
                        <td><strong>50%</strong></td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box">
                <h4>Practical Impact:</h4>
                <p>For a VLSI design with 1 million rectilinear polygons averaging 20 vertices each:</p>
                <ul>
                    <li><strong>Polygon approach</strong>: 20 million vertex objects</li>
                    <li><strong>RPolygon approach</strong>: 10 million vertex objects</li>
                    <li><strong>Memory savings</strong>: 10 million vertex objects (approximately 240MB for typical implementations)</li>
                </ul>

                <p>This dramatic reduction in memory usage translates to:</p>
                <ul>
                    <li><strong>Better cache locality</strong>: Fewer memory accesses per operation</li>
                    <li><strong>Reduced memory bandwidth</strong>: Less data movement between CPU and RAM</li>
                    <li><strong>Lower memory pressure</strong>: Allows larger datasets to fit in available RAM</li>
                    <li><strong>Faster serialization</strong>: Smaller data structures for file I/O and network transfer</li>
                </ul>

                <p>The integer constraint in RPolygon provides additional memory savings in implementations where integers require less storage than floating-point numbers.</p>
            </div>

            <h2><span class="emoji">üé®</span>Visual Examples and Use Cases</h2>
            
            <h3>Example 1: Convex Hull Visualization</h3>
            <p>The following SVG shows a convex hull computed from a set of points using the general polygon algorithm:</p>
            <div class="image-container">
                <img src="outputs/polygon_convex_hull.svg" alt="Polygon Convex Hull" style="max-width: 600px;">
            </div>

            <h3>Example 2: Rectilinear Polygon Structure</h3>
            <p>This SVG demonstrates the characteristic orthogonal edges of a rectilinear polygon:</p>
            <div class="image-container">
                <img src="outputs/rpolyon_convex_hull.svg" alt="RPolygon Convex Hull" style="max-width: 600px;">
            </div>

            <h3>Example 3: X-Monotone Rectilinear Polygon</h3>
            <p>The following visualization shows an x-monotone rectilinear polygon with its characteristic left-to-right vertex ordering:</p>
            <div class="image-container">
                <img src="outputs/rpolyon_xmono.svg" alt="X-Monotone RPolygon" style="max-width: 600px;">
            </div>

            <h2><span class="emoji">üè≠</span>Practical Applications</h2>
            
            <div class="two-column">
                <div>
                    <h3><span class="emoji">üî¨</span>VLSI Physical Design</h3>
                    <p>In VLSI (Very-Large-Scale Integration) design, rectilinear polygons are extensively used for:</p>
                    <ol>
                        <li><strong>Circuit block representation</strong>: Circuit components are typically placed on rectangular grids</li>
                        <li><strong>Routing channels</strong>: The space between components forms rectilinear channels</li>
                        <li><strong>Obstacle representation</strong>: Manufacturing constraints often require orthogonal routing</li>
                    </ol>

                    <p>The <code>RPolygon</code> class is particularly well-suited for these applications due to:</p>
                    <ul>
                        <li>Integer coordinate alignment with manufacturing grids</li>
                        <li>Efficient algorithms for layout optimization</li>
                        <li>Simplified design rule checking</li>
                    </ul>
                </div>
                <div>
                    <h3><span class="emoji">üéÆ</span>Computer Graphics</h3>
                    <p>General polygons find extensive use in:</p>
                    <ol>
                        <li><strong>3D modeling</strong>: Arbitrary shapes for characters and objects</li>
                        <li><strong>Texture mapping</strong>: Complex UV coordinate mapping</li>
                        <li><strong>Collision detection</strong>: Precise boundary representation</li>
                    </ol>

                    <h3><span class="emoji">üó∫Ô∏è</span>Geographic Information Systems (GIS)</h3>
                    <p>Both polygon types are used in GIS applications:</p>
                    <ul>
                        <li><strong>RPolygon</strong>: Urban planning, cadastral systems with orthogonal property boundaries</li>
                        <li><strong>Polygon</strong>: Natural features like lakes, forests, and administrative boundaries</li>
                    </ul>
                </div>
            </div>

            <h2><span class="emoji">üöÄ</span>Algorithmic Optimizations</h2>
            
            <h3>RPolygon-Specific Optimizations</h3>
            
            <h4><span class="emoji">üöÄ</span>1. Even-Index Storage Optimization</h4>
            <p>The most significant optimization in the RPolygon implementation is the <strong>50% storage reduction</strong> through even-index vertex storage. This optimization cascades through all algorithms:</p>

            <div class="highlight-box">
                <h4>Algorithm Adaptation:</h4>
                <pre><code class="language-python"># Traditional polygon iteration
for i in range(n):
    process_vertex(vertices[i])

# RPolygon iteration with implicit reconstruction
for i in range(k):  # k = ceil(n/2)
    process_vertex(vertices[i])
    if i < k - 1:
        # Implicit vertex v_{2i+1} can be reconstructed if needed
        implicit_vertex = reconstruct_implicit_vertex(vertices[i], vertices[i+1])
        process_vertex(implicit_vertex)</code></pre>

                <h4>Memory Access Pattern Benefits:</h4>
                <ul>
                    <li><strong>Sequential Access</strong>: Even-index vertices are accessed contiguously</li>
                    <li><strong>Cache Efficiency</strong>: Better spatial locality in vertex processing</li>
                    <li><strong>Reduced Indirection</strong>: Fewer pointer dereferences during traversal</li>
                </ul>

                <h4>Mathematical Operations:</h4>
                <p>Many polygon operations can be performed directly on the compressed set:</p>
                <ul>
                    <li><strong>Area calculation</strong>: Uses the corner vertices only</li>
                    <li><strong>Bounding box</strong>: Determined by extreme even-index vertices</li>
                    <li><strong>Centroid</strong>: Can be approximated using corner vertices</li>
                    <li><strong>Convexity testing</strong>: Simplified due to alternating edge directions</li>
                </ul>
            </div>

            <h4>2. Simplified Intersection Testing</h4>
            <p>For rectilinear polygons, edge intersection testing reduces to simple coordinate comparisons:</p>
            <pre><code class="language-python">def edges_intersect_rectilinear(e1: Tuple[Point, Point], e2: Tuple[Point, Point]) -> bool:
    # Horizontal vs Vertical edge case
    if e1[0].y == e1[1].y and e2[0].x == e2[1].x:
        return (min(e1[0].x, e1[1].x) <= e2[0].x <= max(e1[0].x, e1[1].x) and
                min(e2[0].y, e2[1].y) <= e1[0].y <= max(e2[0].y, e2[1].y))
    # Similar cases for other edge combinations</code></pre>

            <h4>3. Optimized Area Calculation</h4>
            <div class="math-block">
                <p>The area of a rectilinear polygon can be computed using the "horizontal strip" method:</p>
                $$A = \sum_{i=1}^{n/2} (x_{2i} - x_{2i-1}) \cdot y_i$$
                <p>where vertices are ordered appropriately.</p>
            </div>

            <h4>4. Efficient Decomposition</h4>
            <p>Rectilinear polygons can be efficiently decomposed into rectangles using algorithms like the "trapezoidal decomposition" with $O(n \log n)$ complexity.</p>

            <h3>General Polygon Optimizations</h3>
            
            <h4>1. Spatial Indexing</h4>
            <p>For large polygon sets, spatial indexing structures like R-trees or quadtrees can significantly improve query performance:</p>
            <pre><code class="language-python">class SpatialIndex:
    def __init__(self, polygons: List[Polygon]):
        self.rtree = RTree()
        for i, poly in enumerate(polygons):
            self.rtree.insert(i, poly.bounding_box())
    
    def query_point(self, point: Point) -> List[int]:
        candidates = self.rtree.query(point.bounding_box())
        return [i for i in candidates if point_in_polygon(polygons[i].vertices, point)]</code></pre>

            <h4>2. Parallel Processing</h4>
            <p>Polygon operations can be parallelized for large datasets:</p>
            <pre><code class="language-python">def parallel_point_in_polygon(polygons: List[Polygon], points: List[Point]) -> List[List[bool]]:
    with ThreadPoolExecutor() as executor:
        futures = [executor.submit(check_poly_point, poly, points) for poly in polygons]
        return [future.result() for future in futures]</code></pre>

            <h2><span class="emoji">‚úÖ</span>Testing and Validation</h2>
            
            <h3>Unit Testing Strategies</h3>
            <p>Both polygon classes include comprehensive test suites:</p>

            <h4>Polygon Tests</h4>
            <pre><code class="language-python">def test_polygon() -> None:
    coords = [
        (-2, 2), (0, -1), (-5, 1), (-2, 4), (0, -4),
        (-4, 3), (-6, -2), (5, 1), (2, 2), (3, -3),
        (-3, -3), (3, 3), (-3, -4), (1, 4),
    ]
    S = [Point(xcoord, ycoord) for xcoord, ycoord in coords]
    S = create_test_polygon(S)
    assert polygon_is_anticlockwise(S)
    P = Polygon.from_pointset(S)
    assert P.signed_area_x2 == 110
    assert P.is_anticlockwise()</code></pre>

            <h4>RPolygon Tests</h4>
            <pre><code class="language-python">def test_RPolygon() -> None:
    coords = [
        (-2, 2), (0, -1), (-5, 1), (-2, 4), (0, -4),
        (-4, 3), (-6, -2), (5, 1), (2, 2), (3, -3),
        (-3, -4), (1, 4),
    ]
    S, is_cw = create_ymono_rpolygon(
        [Point(xcoord, ycoord) for xcoord, ycoord in coords]
    )
    P = RPolygon.from_pointset(S)
    assert not is_cw
    assert P.is_anticlockwise()
    G = P.to_polygon()
    assert P.signed_area * 2 == G.signed_area_x2</code></pre>

            <h3>Property-Based Testing</h3>
            <p>Using hypothesis for property-based testing:</p>
            <pre><code class="language-python">@given(st.lists(st.tuples(st.integers(), st.integers()), min_size=3, max_size=10))
def test_polygon_area_property(coords):
    points = [Point(x, y) for x, y in coords]
    polygon = Polygon.from_pointset(points)
    # Area should be invariant under translation
    translated = Polygon.from_pointset([Point(p.xcoord + 5, p.ycoord + 5) for p in points])
    assert polygon.signed_area_x2 == translated.signed_area_x2</code></pre>

            <h2><span class="emoji">üîÆ</span>Future Directions and Extensions</h2>
            
            <h3>Potential Enhancements</h3>
            <ol>
                <li><strong>GPU Acceleration</strong>: Leverage CUDA/OpenCL for massive parallel polygon operations</li>
                <li><strong>Machine Learning Integration</strong>: Neural networks for polygon classification and similarity detection</li>
                <li><strong>Streaming Algorithms</strong>: Process polygon streams with limited memory</li>
                <li><strong>Approximation Algorithms</strong>: Trade accuracy for performance in large-scale applications</li>
            </ol>

            <h3>Emerging Applications</h3>
            <ol>
                <li><strong>Computational Fabrication</strong>: 3D printing with orthogonal constraints</li>
                <li><strong>Robotics Path Planning</strong>: Configuration space obstacles</li>
                <li><strong>Spatial Databases</strong>: Efficient polygon indexing and querying</li>
                <li><strong>Computer Vision</strong>: Shape recognition and analysis</li>
            </ol>

            <div class="conclusion">
                <h2><span class="emoji">üéØ</span>Conclusion</h2>
                <p>The <code>Polygon</code> and <code>RPolygon</code> classes in the physdes-py library represent two complementary approaches to geometric computation. While general polygons provide maximum flexibility for arbitrary shapes, rectilinear polygons offer significant performance advantages for orthogonal geometry problems.</p>

                <p><strong>Key takeaways:</strong></p>
                <ol>
                    <li><strong>Performance vs. Flexibility</strong>: RPolygon trades flexibility for performance in orthogonal domains</li>
                    <li><strong>Algorithmic Specialization</strong>: Rectilinear constraints enable specialized algorithms with better asymptotic properties</li>
                    <li><strong>Application-Driven Design</strong>: The choice between polygon types should be driven by specific application requirements</li>
                    <li><strong>Interoperability</strong>: The conversion methods between types enable hybrid approaches</li>
                </ol>

                <p>The thoughtful design of both classes, with their shared interfaces and specialized optimizations, provides a robust foundation for computational geometry applications. As computational requirements continue to grow, the principles demonstrated in these implementations‚Äîtype safety, algorithmic efficiency, and application-specific optimization‚Äîwill remain valuable guides for future geometric computing systems.</p>
            </div>

            <div class="references">
                <h2><span class="emoji">üìö</span>References</h2>
                <ol>
                    <li>O'Rourke, J. (1998). <em>Computational Geometry in C</em> (2nd ed.). Cambridge University Press.</li>
                    <li>de Berg, M., Cheong, O., van Kreveld, M., & Overmars, M. (2008). <em>Computational Geometry: Algorithms and Applications</em> (3rd ed.). Springer.</li>
                    <li>Preparata, F. P., & Shamos, M. I. (1985). <em>Computational Geometry: An Introduction</em>. Springer-Verlag.</li>
                    <li>Lengauer, T. (1990). <em>Combinatorial Algorithms for Integrated Circuit Layout</em>. Wiley-Teubner.</li>
                </ol>
            </div>

            <hr>
            <p><em>This essay has explored the intricate relationship between general and rectilinear polygons through the lens of the physdes-py library implementations. The code examples and visualizations demonstrate practical applications of theoretical concepts in computational geometry.</em></p>
        </main>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ startOnLoad: true });

        // Initialize Prism for code highlighting
        Prism.highlightAll();

        // Add smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });

        // Add interactive table of contents
        const headings = document.querySelectorAll('h2, h3, h4');
        const toc = document.createElement('div');
        toc.innerHTML = '<h3>Table of Contents</h3><ul></ul>';
        toc.style.position = 'fixed';
        toc.style.right = '20px';
        toc.style.top = '100px';
        toc.style.width = '250px';
        toc.style.maxHeight = '70vh';
        toc.style.overflow = 'auto';
        toc.style.background = 'white';
        toc.style.padding = '1rem';
        toc.style.borderRadius = '8px';
        toc.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
        toc.style.zIndex = '1000';

        const tocList = toc.querySelector('ul');
        headings.forEach((heading, index) => {
            const id = `heading-${index}`;
            heading.id = id;
            
            const li = document.createElement('li');
            li.style.marginBottom = '0.5rem';
            
            const a = document.createElement('a');
            a.href = `#${id}`;
            a.textContent = heading.textContent;
            a.style.color = '#2c3e50';
            a.style.textDecoration = 'none';
            a.style.fontSize = heading.tagName === 'H2' ? '1rem' : heading.tagName === 'H3' ? '0.9rem' : '0.8rem';
            a.style.paddingLeft = heading.tagName === 'H3' ? '1rem' : heading.tagName === 'H4' ? '2rem' : '0';
            
            a.addEventListener('mouseover', () => a.style.color = '#3498db');
            a.addEventListener('mouseout', () => a.style.color = '#2c3e50');
            
            li.appendChild(a);
            tocList.appendChild(li);
        });

        document.body.appendChild(toc);

        // Hide/show table of contents on scroll
        let lastScrollTop = 0;
        window.addEventListener('scroll', () => {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            if (scrollTop > lastScrollTop && scrollTop > 200) {
                toc.style.transform = 'translateX(300px)';
                toc.style.transition = 'transform 0.3s ease';
            } else {
                toc.style.transform = 'translateX(0)';
                toc.style.transition = 'transform 0.3s ease';
            }
            lastScrollTop = scrollTop;
        });
    </script>
</body>
</html>